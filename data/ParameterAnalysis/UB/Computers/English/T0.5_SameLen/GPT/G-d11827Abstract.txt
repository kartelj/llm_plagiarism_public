The study posited that chip multiprocessors' (CMP) resources, with extra hardware and/or software backing for Thread Level Speculation (TLS), can be utilized for executing prevalent sequential applications. However, certain CMPs with TLS support necessitate substantial supplementary hardware and software resources for specific operations during speculative execution of sequential applications. Thus, a detailed comparative analysis of speculative CMPs was conducted, focusing on hardware and software support for speculation at both register and memory levels. Existing systems were categorized based on register level communication support, register file organization, and interconnection topology. The analysis compared registration communication mechanisms, misspeculation recovery techniques, and performance and scalability. Systems were also classified based on memory level communication support and memory hierarchy organization, and the complexity of hardware and software support for speculation was discussed. Potential performance degradation factors such as burst traffic on thread commit and unsuitable cache memory replacement algorithms were considered. Based on the analysis, a CMP with simpler TLS support was proposed to improve cost/performance and eliminate inefficiencies. The proposed speculative CMP is a system with a generic architecture enhanced with support for register and memory speculative communication. It comprises four processing cores with private data and instruction L1 caches, connected by a shared bus to a shared L2 cache. Speculative communication at the register and memory level occurs through corresponding shared buses following snoopy protocols principles. Speculative parallelization is implemented at the loop level, and speculative threads correspond to loop iterations. Speculative threads are identified using a binary annotator, a special software component that operates on sequential executable code without source code recompilation. This tool also annotates write instructions to loop-alive registers for the protocol controlling the register level communication. Speculatively produced memory values are kept in private L1 caches, while the shared L2 cache stores the sequential state. Memory values can be transferred to the L2 cache only after a thread becomes non-speculative. The proposed solution implements support for dynamic identification of data dependence violations and recovery from misspeculation. Two protocols are proposed for register communication: the basic SIC protocol and its extended version, the ESIC protocol, which is based on speculative forwarding of potentially safe register values. Qualitative comparison of the SIC and ESIC protocols indicates potential performance gain in the ESIC compared to the SIC protocol. This gain results from reduced blocking of consumer threads and directly depends on the probability that forwarded, potentially safe, register value turns out to be final. Otherwise, misspeculation causes thread squashing which may hurt performance. By using profiler provided information on the probability of successful speculation, the frequency of thread squashing can be decreased. The SIC and ESIC protocols use a distributed arbitration mechanism for efficiently finding data supplier threads. Additionally, the number of invalidation misses for non loop-alive registers in SIC and ESIC protocols is reduced by using a read-snarfing technique. As for complexity, both protocols are scalable as the size of the local directory and hardware support remain almost constant while increasing the number of processor cores. Three variants of memory protocols integrating cache coherence with speculation support are proposed. The first variant, the SISC-WI protocol, is invalidation-based and uses 13 states. It allows consumer-initiated communication between speculative threads only. The second variant, the SISC-WI-RS protocol, reduces the number of invalidation misses using a read-snarfing technique for simultaneous validation of invalidated copies. The third variant, the SISC-WU protocol, is update-based and uses 9 states. It allows both producer- and consumer-initiated communication between speculative threads. In addition to state bits, there is a bit per each word in the L1 cache indicating if the word is stale. Again, distributed arbitration on the shared bus is proposed for the selection of appropriate data suppliers at a thread request. Also, all three memory protocols employ a modified cache memory replacement algorithm which first takes into account a word state, instead of history-based algorithms in all other systems. A speculative thread can evict a modified committed word from the L1 cache during speculative read or write operations to this word since it is the only copy. In addition, all the words that are not speculatively read or modified can be considered for replacement, thus avoiding unnecessary stalling of speculative execution. A new simulation environment based on the UNISIM modular cycle-level simulator was developed for the implementation and evaluation analysis of the proposed support. Then, the most complex part of the overall proposed TLS support, the SISC-WI protocol, was chosen for implementation in this simulation environment. To make this possible, extensive modifications were made to some existing standard UNISIM simulator modules: the cache memory, the cache controller, and the system bus. On top of this, a speculative multi-core MIPS architecture was simulated and three new modules were included: Scheduler, Squash Arbiter, and Supplier Arbiter. The Squash Arbiter module for the detection and resolution of misspeculation successfully solved some problems related to thread squashing that are not considered in the open literature. Additionally, a cross-compiler based on the crosstool-NG framework was developed. Finally, the implementation of the SISC-WI protocol in the simulation environment proved the concept's validity.