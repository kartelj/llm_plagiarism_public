This study hypothesized that chip multiprocessors (CMP) resources, supplemented with additional hardware and/or software for Thread Level Speculation (TLS), can be utilized for executing prevalent sequential applications. However, some CMPs with TLS support necessitate significant additional hardware and software resources for specific operations during speculative execution of sequential applications. Consequently, a comprehensive and detailed comparative analysis of speculative CMPs was conducted, focusing on hardware and software support for speculation at both register and memory levels. Based on register level communication support, existing systems were categorized by register file organization and interconnection topology. A comparative analysis of registration communication mechanisms, misspeculation recovery techniques, and performance and scalability was then presented. Existing systems were classified by the organization of the memory hierarchy based on memory level communication support, and the complexity of hardware and software support for speculation was discussed. Potential causes for performance degradation, such as burst traffic on thread commit and inappropriate cache memory replacement algorithm, were considered. A simpler TLS support CMP, which facilitates communication between speculative threads at both register and memory levels, was proposed in this dissertation to achieve better cost/performance and eliminate observed inefficiencies. The proposed speculative CMP is essentially a generic architecture system enhanced with support for register and memory speculative communication. It comprises four processing cores with private data and instruction L1 caches connected by a shared bus to a shared L2 cache. Speculative communication at the register and memory level is conducted through corresponding shared buses following snoopy protocol principles. Speculative parallelization is implemented at the loop level, and speculative threads correspond to loop iterations. Speculative threads are identified using a binary annotator, a special software component that operates on sequential executable code without requiring source code recompilation. This tool also annotates write instructions to loop-alive registers for the protocol controlling register level communication. Speculatively produced memory values are stored in private L1 caches, while the shared L2 cache stores the sequential state. Memory values can only be transferred to the L2 cache once a thread becomes non-speculative. The speculative thread can read data from a non-speculative thread or a preceding or subsequent speculative thread. The proposed solution implements support for dynamic identification of data dependence violations and recovery from misspeculation. Two protocols for register communication are proposed: the basic SIC protocol and its extended version, the ESIC protocol, which is based on speculative forwarding of potentially safe register values. A qualitative comparison of the SIC and ESIC protocols indicates potential performance gain in the ESIC compared to the SIC protocol. This gain results from reduced consumer thread blocking and depends directly on the probability that a forwarded, potentially safe, register value is final. Otherwise, misspeculation causes thread squashing, which may negatively impact performance. Using profiler-provided information on the probability of successful speculation can reduce the frequency of thread squashing. The SIC and ESIC protocols use a distributed arbitration mechanism to efficiently find data supplier threads. Additionally, the number of invalidation misses for non-loop-alive registers in SIC and ESIC protocols is reduced using the read-snarfing technique. In terms of complexity, both protocols are scalable as the size of the local directory and hardware support remain almost constant while increasing the number of processor cores. Three variants of memory protocols that integrate cache coherence with speculation support are proposed. The first variant, the SISC-WI protocol, is invalidation-based and uses 13 states. It allows only consumer-initiated communication between speculative threads. The second variant, the SISC-WI-RS protocol, aims to reduce the number of invalidation misses using the read-snarfing technique for simultaneous validation of invalidated copies. The third variant, the SISC-WU protocol, is update-based and uses 9 states. It allows both producer- and consumer-initiated communication between speculative threads. In addition to state bits, there is a bit for each word in the L1 cache indicating if the word is stale. Distributed arbitration on the shared bus is proposed for selecting appropriate data suppliers at a thread request. All three memory protocols also use a modified cache memory replacement algorithm that first considers a word state, unlike history-based algorithms in all other systems. A speculative thread is allowed to evict a modified committed word from the L1 cache during speculative read or write operations to this word as it is the only copy. Additionally, all words that are not speculatively read or modified can be considered for replacement, thus avoiding unnecessary stalling of speculative execution. A new simulation environment based on the UNISIM modular cycle-level simulator was developed for implementing and evaluating the proposed support. The most complex part of the overall proposed TLS support, the SISC-WI protocol, was chosen for implementation in this simulation environment. To make this possible, some existing standard UNISIM simulator modules, such as the cache memory, the cache controller, and the system bus, had to be extensively modified. A speculative multi-core MIPS architecture was simulated, and three new modules were included: Scheduler, Squash Arbiter, and Supplier Arbiter. The Squash Arbiter module for detecting and resolving misspeculation successfully solved some problems related to thread squashing that were not considered in the open literature. A cross-compiler based on the crosstool-NG framework was also developed. Finally, the implementation of the SISC-WI protocol in the simulation environment validated the concept.