In this research it was assumed that resources of chip multiprocessors (CMP), with additional hardware and/or software support for Thread Level Speculation (TLS) can be exploited for the execution of sequential applications which prevail today. However, some existing CMPs with TLS support require substantial additional hardware and software resources to perform specific operations during speculative execution of sequential applications. Therefore, an extensive and very detailed comparative analysis of existing speculative CMPs is performed focusing on hardware and software support for the speculation on both register and memory levels. According to the register level communication support, existing systems are classified by the organization of register file and interconnection topology. Then, a comparative analysis of registration communication mechanisms, misspeculation recovery techniques, and performance and scalability, are presented. According to the memory level communication support, existing systems are classified by the organization of the memory hierarchy, and then, the complexity of hardware and software support for speculation is discussed. Some potential causes for performance degradation such as burst traffic on thread commit and inappropriate replacement algorithm for cache memories are considered. Based on the analysis of existing speculative CMPs, in order to achieve a better cost/performance and to eliminate the observed inefficiencies, a CMP with a simpler TLS support, which enables the communication between speculative threads on both register and the memory level, is proposed in this dissertation. The proposed speculative CMP belongs to the systems with basically generic architecture enhanced with support for register and memory speculative communication. It consists of four processing cores with private data and instruction L1 caches which are connected by a shared bus to a shared L2 cache. The speculative communication at the register and memory level is done through corresponding shared buses following the principles of snoopy protocols. Speculative parallelization is implemented at the loop level and speculative threads correspond to the loop iterations. Speculative threads are identified using the binary annotator, the special software component that operates on a sequential executable code without need for source code recompilation. In addition, this tool annotates write instructions to loop-alive registers for the purpose of protocol that controls the register level communication. Speculatively produced memory values are kept in private L1 caches, while shared L2 cache stores the sequential state. Memory values can be transferred to the L2 cache only after a thread becomes non-speculative. The speculative thread can read data from non-speculative thread or some preceding or subsequent speculative thread. The proposed solution implements a support for dynamic identification of data dependence violations and recovery from misspeculation. Two protocols are proposed for register communication: the basic version â€“ the SIC protocol, and its extended version - the ESIC protocol which is, unlike the SIC, based on speculative forwarding of potentially safe register values. Qualitative comparison of the SIC and ESIC protocols indicate a potential performance gain in the ESIC compared to the SIC protocol. This gain is a result of reduced blocking of consumer threads and it directly depends on the probability that forwarded, a potentially safe, register value turns out to be final. Otherwise, the misspeculation causes thread squashing which may have hurt the performance. By using profiler provided information on probability of successful speculation it is possible to decrease the frequency of thread squashing. The SIC and ESIC protocols employ a mechanism of distributed arbitration for efficiently finding the data supplier threads. Besides, the number of invalidation misses for non loop-alive registers in SIC and ESIC protocols is reduced by using read-snarfing technique. As for the complexity, both protocols are scalable since the size of the local directory and hardware support remain almost constant while increasing the number of processor cores. Three variants of the memory protocols that integrate the cache coherence with the support for speculation are proposed. The first variant, the SISC-WI protocol, is invalidation-based and uses 13 states. It allows consumer-initiated communication between speculative threads only. The second variant, the SISC-WI-RS protocol, tends to reduce the number of invalidation misses using read-snarfing technique for simultaneous validation of invalidated copies. The third variant, the SISC-WU protocol, is update-based and uses 9 states. It allows both producer- and consumer-initiated communication between speculative threads. In addition to state bits, there is a bit per each word in L1 cache which indicates if the word is stale. Again, distributed arbitration on the shared bus is proposed for the selection of appropriate suppliers of data at a thread request. Also, all three memory protocols employ a modified cache memory replacement algorithm which first takes into account a word state, instead of history- based algorithms in all other systems. A speculative thread is allowed to evict a modified committed word from the L1 cache during speculative read or write operations to this word since it is the only copy. In addition, all the words that are not speculatively read or modified can be considered for replacement, thus avoiding the unnecessary stalling of speculative execution. A new simulation environment based on the UNISIM modular cycle-level simulator is developed for the purpose of implementation and evaluation analysis of the proposed support. Then, the most complex part of the overall proposed TLS support, the SISC- WI protocol, is chosen for implementation in such a simulation environment. In order to make this possible it was necessary to extensively modify some existing standard UNISIM simulator modules: the cache memory, the cache controller and the system bus. On top of this, a speculative multi-core MIPS architecture is simulated and three new modules are included: Scheduler, Squash Arbiter and Supplier Arbiter. The Squash Arbiter module for the detection and resolving of misspeculation successfully solved some problems related to thread squashing that are not considered in the open literature. Besides, the cross-compiler based on the crosstool-NG framework is developed. Finally, the implementation of the SISC-WI protocol in the simulation environment proved the validity of the concept.